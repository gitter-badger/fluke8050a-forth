\ load development code
\ needs l

reset
led ios!

0 variable zero

128 4 + buffer: usb-in-ring
64 4 + buffer: usb-out-ring

: usb-init-rings ( -- )
  usb-in-ring 128 init-ring
  usb-out-ring 64 init-ring ;

: ep-setup ( ep -- )  \ setup packets, sent from host to config this device
  dup rxclear
  cr ." setup: " $48 $40 do i usb-pma@ h.4 space 2 +loop
  $41 usb-pma c@ case
    $00 of zero 2 send-data endof
    $06 of send-desc endof
\   $20 of usb:line 7 send-data endof
\   $22 is baud rate?
\   $23 is break?
    true ?of 0 0 send-data endof
  endcase
  ep-reset-rx# send-next
;

: usb-recv ( c -- ) usb-in-ring dup ring? if >ring else 2drop then ;

: usb-recv2 ( c -- )
  dup usb-recv
\ dup $C0 usb-pma! 1 1 1 ep-reg h! 1 3 txstat!  \ immediate echo
  [char] < emit
  dup bl < if h.2 else emit then
  [char] > emit ;

: ep-out ( ep -- )  \ outgoing packets, sent from host to this device
  dup rxclear
  dup if  \ only pick up data for endpoint 3
    dup 3 ep-reg h@ $3F and 0 ?do
      i $100 + usb-pma c@ usb-recv2
    loop
  then
  ep-reset-rx#
;

: ep-in ( ep -- )  \ incoming polls, sent from this device to host
  dup txclear [char] I emit .
\ txclear
  $41 usb-pma c@ $05 = if $42 usb-pma@ $80 or USB-DADDR h! then
  send-next
;

: usb-ctr ( istr -- )
  dup $07 and swap $10 and if 
    dup ep-addr h@ $800 and if ep-setup else ep-out then
  else ep-in then ;

: usb. ( -- )  \ dump USB info
  cr ." EP0R " 0 ep-addr h@ h.4
    ."  EP1R " 1 ep-addr h@ h.4
    ."  EP2R " 2 ep-addr h@ h.4
    ."  EP3R " 3 ep-addr h@ h.4
  cr ." CNTR " USB-CNTR h@ h.4
    ."  ISTR " USB-ISTR h@ h.4
     ."  FNR " USB-FNR h@ h.4
   ."  DADDR " USB-DADDR h@ h.4
  ."  BTABLE " USB-BTABLE h@ h.4 ;

: usb.mem ( -- )  \ dump packet buffer memory
  $150 0 do
    i $0F and 0= if cr i h.4 space then
    i $7 and 0= if space then
    i shl USBMEM + h@ h.4 space
  2 +loop ;

5000 buffer: outbuf
0 variable outpos

: buf-emit? true ;
: buf-emit outpos @ dup 5000 < if outbuf + c!  1 outpos +!  else drop then ;

: save-to-buf
  ['] buf-emit? hook-emit? !
  ['] buf-emit hook-emit !
  0 outpos ! ;
: restore-buf
  ['] serial-emit? hook-emit? !
  ['] serial-emit hook-emit !
  outbuf outpos @ type  0 outpos ! ;

: test-buf save-to-buf ." abc" [char] : serial-emit restore-buf ;

: usb-poll
  USB-ISTR h@
  dup $8000 and if dup usb-ctr          $7FFF USB-ISTR h! then
  dup $0400 and if usb-reset            $FBFF USB-ISTR h! then
  dup $0800 and if %1100 USB-CNTR hbis! $F7FF USB-ISTR h! then
      $1000 and if %1000 USB-CNTR hbic! $EFFF USB-ISTR h! then ;

: usb-key? ( -- f )  usb-poll usb-in-ring ring# 0<> ;
: usb-key ( -- c )  begin usb-key? until  usb-in-ring ring> ;
: usb-emit? ( -- f )  usb-poll usb-out-ring ring? ;
: usb-emit ( c -- )  begin usb-emit? until  usb-out-ring >ring ;

: myquit begin query interpret ." OK!" cr again ;

: +usb-io ( -- )
  usb-init-rings
\ $0D usb-in-ring >ring
  ['] usb-key? hook-key? !
  ['] usb-key hook-key !
\ ['] usb-emit? hook-emit? !
\ ['] usb-emit hook-emit !
\ ['] myquit hook-quit !
;

: -usb-io ( -- )
  ['] serial-key? hook-key? !
  ['] serial-key hook-key !
\ ['] serial-emit? hook-emit? !
\ ['] serial-emit hook-emit !
  usb-in-ring ring# .
  usb-out-ring ring# .
;

: try ( -- ) +usb-io begin usb-poll serial-key? until -usb-io ;

: t +usb try usb. ( usb.mem ) -usb ;
: t2 save-to-buf +usb try usb. usb.mem -usb restore-buf ;

\ vim: set ft=forth :
