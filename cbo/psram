\ -----------------------------------------------------------------------------
\ PSRAM on HY-STM32F1xxCore144 Core/Dev Board
\ (addtional PSRAM memory debugging stuff - louie@transsys.com)

compiletoram

$A0000008 constant FSMC-BCR2
$A000000C constant FSMC-BTR2

: psram-pins ( -- )
  8 bit RCC-AHBENR bis!  \ enable FSMC clock
  OMODE-AF-PP OMODE-FAST + dup PD0 %1111111100110011 io-modes!
                           dup PE0 %1111111111111011 io-modes!
                           dup PF0 %1111000000111111 io-modes!
                               PG0 %0000001000111111 io-modes! ;

: psram-fsmc ( -- )
  $80               \ keep reset value
\                   \ FSMC_DataAddressMux_Disable
  %01 2 lshift or   \ FSMC_MemoryType_PSRAM
  %01 4 lshift or   \ FSMC_MemoryDataWidth_16b
\                   \ FSMC_BurstAccessMode_Disable
\                   \ FSMC_WaitSignalPolarity_Low
\                   \ FSMC_WrapMode_Disable
\                   \ FSMC_WaitSignalActive_BeforeWaitState
  1 12 lshift or    \ FSMC_WriteOperation_Enable
\                   \ FSMC_WaitSignal_Disable
\                   \ FSMC_AsynchronousWait_Disable
\                   \ FSMC_ExtendedMode_Disable
\                   \ FSMC_WriteBurst_Disable
  FSMC-BCR2 !

\ for 72 MHz, i.e. 13.89 ns per clock cycle
\ assuming address setup > 70 ns and data setup > 20 ns + 1 cycle
\ started with addr/data/turn as 5/2/1, but even 1/1/0 seems to work fine...

  0
  10  0 lshift or    \ FSMC_AddressSetupTime = 6 
                    \ FSMC_AddressHoldTime = 0
  10  8 lshift or    \ FSMC_DataSetupTime = 3
  1 16 lshift or    \ FSMC_BusTurnAroundDuration = 2
                    \ FSMC_CLKDivision = 0x00
                    \ FSMC_DataLatency = 0x00
                    \ FSMC_AccessMode_A
  FSMC-BTR2 !

  1 FSMC-BCR2 bis!  \ MBKEN:Memorybankenablebit
;

$64000000 constant PSRAM
23 bit    constant PSRAM-SIZE

: psram-init ( -- )  \ set up FSMC access to 8 MB PSRAM in bank 2
  psram-pins psram-fsmc ;

\ see http://compgroups.net/comp.lang.forth/random-number-generator/1259025
\ only last bit should be used, but for this purpose we can use all 32 bits

123456789 variable seed

: random ( -- u ) seed @ dup ror or seed @ rol xor dup seed ! ;

: r 0 do random hex. loop ;

: psram-test ( u -- )  \ test first N bytes of PSRAM, original data is lost
  psram-init
  $12345678 seed !
  dup 0 do
    random PSRAM i + !  \ fill it with random values
  4 +loop
  \ turn off dump to reduce noise in repeated test runs
  \ PSRAM $40 dump
  $12345678 seed !
  0 do
    random PSRAM i + @  \ now read those values back and compare
    <> if i cr hex. ." FAILED!" cr leave then
  4 +loop ;

: psram-full ( -- )  \ test entire 8 MB PSRAM, then clear its contents
  PSRAM-SIZE  dup psram-test  PSRAM swap 0 fill ;

 : psram-time ( -- )  \ measure read and write times for a full scan
   psram-init
   micros  23 bit 0 do                      4 +loop  micros swap - .
   micros  23 bit 0 do  i             drop  4 +loop  micros swap - .
   micros  23 bit 0 do    PSRAM i + @ drop  4 +loop  micros swap - .
   micros  23 bit 0 do  i PSRAM i + !       4 +loop  micros swap - . ;

\ sample output: 495471 641201 1486421 1369795

\  -----------------------------------------------------------
\  some tests that avoid using the random number generator

: tester1  ( -- )    \ fill memory with offset from start of PSRAM
  PSRAM-SIZE PSRAM +  PSRAM do
    i dup !  \ store address into the memory at the same location
    i dup @ <> if cr hex. ." tester FAILED" cr leave then
  4 +loop ;

: tester2  ( -- )    \ fill memory with address of location
  PSRAM-SIZE 0 do
    i dup PSRAM + !
    i dup PSRAM + @ <> if cr hex. ." tester2 FAILED" cr leave then
  4 +loop ;

: looping-tester ( --)  \ 
  10000 0 do
    psram-full tester1 tester2
    i .
    key? if cr ." ended" cr leave then 
  loop ;

\  -----------------------------------------------------------
\  tests that fill one half of PSRAM and copy it to the other half, 
\  and then verify two copies are consistent.  

: fill-half      ( -- )    \ fill the first half of PSRAM with a repeatable pseudo-random sequence
  $12345678 seed !
  PSRAM-SIZE 2/ 0 do
    random PSRAM i + ! \ fill with random value
  4 +loop ;

: copy-half     ( -- )     \ copy first half of PSRAM to second half
  PSRAM   PSRAM PSRAM-SIZE 2/ +   PSRAM-SIZE 2/   move ;

: compare-halves ( -- )    \ compare the two halves of PSRAM and ensure they correspond
  PSRAM-SIZE 2/ 0 do
    PSRAM i + dup          \ location in lower half
    PSRAM-SIZE 2/ + @	   \ location in upper half and contents
    swap @     	    	   \ get lower half contents
    2dup <> 
    if 
      cr ." Compare error @" i hex. hex. hex.
      ." [re-read: " PSRAM i + @ hex. PSRAM i + PSRAM-SIZE 2/ + @ hex. ." ]"      
      cr
    else
      2drop
    then 
  4 +loop ;

: verify-halves  ( -- )    \ verify that each half still contains the correct psesudo-random
  ." [1st]"      	   \ sequence based on the genertor
  $12345678 seed !
  PSRAM-SIZE 2/ 0 do
    PSRAM i + @ random 2dup  ( PSRAM@ random PSRAM@ random )
    <> if   ( PSRAM@ random )
      cr
      ." miscompare @" i hex. ( PSRAM@ random )
      tuck                    ( random PSRAM@ random )
      ." R:" hex. ( random PSRAM@ )
      ." M:" hex. ( random )
      ." [re-read: R:" hex. PSRAM i + @ ." M:" hex. ." ]"
      cr
    else 
      2drop
    then
  4 +loop 

  $12345678 seed !
   ." [2nd] "
  PSRAM-SIZE 2/ 0 do
    PSRAM i + PSRAM-SIZE 2/ + @ random 2dup <> 
    if
      cr
      ." miscompare @" i  hex.
      tuck
      ." R:" hex.
      ." M:" hex.
      ." [re-read: R:" hex.  PSRAM i + PSRAM-SIZE 2/ + @ ." M:" hex. ." ]"
      cr 
    else
      2drop
    then

  4 +loop ;
  
\ fill both PSRAM halves with pseudo random sequence, and then repeated compare the two halves
\ every so often, ensure that the two halves are still the same correct pseudo-random sequence
: read-tester   ( -- )
  psram-init   fill-half  copy-half
  10000 0 do
    \ every so often, verify both halves still contain the same random numbers
    i 50 mod 0 = if verify-halves then
    i . 
    compare-halves
    key? if cr ." ended" cr leave then
  loop ;

\ fill PSRAM botth half with pseudo random sequence, and then 
\ repeatedly copy the lower half to the upper half and compare for correctness
\ every so often, verify against the correct pseudo-random sequence
: rw-tester
  psram-init  fill-half  copy-half
  10000 0 do
    \ every so often, verify both halves still contain the same random numbers
    i 50 mod 0 = if verify-halves then
    i .
    compare-halves
    key? if cr ." ended" cr leave then
    copy-half
  loop ;

\ fill both halves of PSRAM with the same pseudo random sequence.  then repeatedly
\ verify that both halves still contain the same sequence 
: verify-tester
  psram-init  fill-half  copy-half 
  10000 0 do 
      i .
      verify-halves
      key? if cr ." ended" cr leave then
  loop ;
